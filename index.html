<!DOCTYPE html>
<html>
<head>
    <title>Arcane Archer - Working Version</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; }
        canvas { display: block; }
        #hud { position: fixed; top: 10px; left: 10px; color: white; font-family: Arial; }
        #menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; }
        button { padding: 15px 30px; font-size: 18px; background: #4CAF50; border: none; color: white; cursor: pointer; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="menu">
        <h1>Arcane Archer</h1>
        <button onclick="startGame()">Start Game</button>
        <p>Drag back to aim, release to shoot!</p>
    </div>
    <div id="hud"></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game State
        let gameState = 'menu';
        let bow = { x: 100, y: canvas.height/2, angle: 0 };
        let arrows = [];
        let targets = [];
        let score = 0;
        let isAiming = false;
        let aimStart = { x: 0, y: 0 };

        // Game Functions
        function startGame() {
            gameState = 'playing';
            document.getElementById('menu').style.display = 'none';
            score = 0;
            arrows = [];
            targets = [];
            spawnTarget();
            gameLoop();
        }

        function spawnTarget() {
            targets.push({
                x: canvas.width - 100 - Math.random() * 300,
                y: Math.random() * (canvas.height - 200) + 100,
                size: 30,
                color: '#4CAF50'
            });
        }

        function updateGame() {
            // Update arrows
            arrows.forEach((arrow, index) => {
                arrow.x += arrow.velocity.x;
                arrow.y += arrow.velocity.y;
                arrow.velocity.y += 0.3;
                
                // Remove arrows out of bounds
                if (arrow.x < 0 || arrow.x > canvas.width || arrow.y > canvas.height) {
                    arrows.splice(index, 1);
                }
            });

            // Check collisions
            arrows.forEach((arrow, aIndex) => {
                targets.forEach((target, tIndex) => {
                    const dx = arrow.x - target.x;
                    const dy = arrow.y - target.y;
                    if (Math.sqrt(dx*dx + dy*dy) < target.size) {
                        arrows.splice(aIndex, 1);
                        targets.splice(tIndex, 1);
                        score += 100;
                        spawnTarget();
                    }
                });
            });
        }

        function drawGame() {
            // Clear canvas
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.fillStyle = '#1B5E20';
            ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

            // Draw bow
            ctx.save();
            ctx.translate(bow.x, bow.y);
            ctx.rotate(bow.angle);
            ctx.font = '40px Arial';
            ctx.fillText('🏹', -20, 10);
            ctx.restore();

            // Draw arrows
            arrows.forEach(arrow => {
                ctx.save();
                ctx.translate(arrow.x, arrow.y);
                ctx.rotate(Math.atan2(arrow.velocity.y, arrow.velocity.x));
                ctx.fillStyle = '#B0BEC5';
                ctx.fillRect(-15, -3, 30, 6);
                ctx.restore();
            });

            // Draw targets
            targets.forEach(target => {
                ctx.beginPath();
                ctx.arc(target.x, target.y, target.size, 0, Math.PI*2);
                ctx.fillStyle = target.color;
                ctx.fill();
            });

            // Draw HUD
            document.getElementById('hud').innerHTML = `Score: ${score}`;
        }

        // Input Handling
        canvas.addEventListener('mousedown', (e) => {
            if (gameState === 'playing') {
                isAiming = true;
                aimStart = { x: e.clientX, y: e.clientY };
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isAiming) {
                bow.angle = Math.atan2(e.clientY - bow.y, e.clientX - bow.x);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isAiming && gameState === 'playing') {
                isAiming = false;
                const velocity = {
                    x: (aimStart.x - e.clientX) / 10,
                    y: (aimStart.y - e.clientY) / 10
                };
                arrows.push({
                    x: bow.x + 30 * Math.cos(bow.angle),
                    y: bow.y + 30 * Math.sin(bow.angle),
                    velocity: velocity
                });
            }
        });

        // Game Loop
        function gameLoop() {
            if (gameState === 'playing') {
                updateGame();
                drawGame();
            }
            requestAnimationFrame(gameLoop);
        }

        // Initial setup
        spawnTarget();
    </script>
</body>
</html>
